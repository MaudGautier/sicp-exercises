; Defining the queue as a procedure instead of a pair of pointers
(define (make-queue)
  (let ((front-ptr '())
         (rear-ptr '()))
    (define (empty-queue?)
      (null? front-ptr))
    (define (print-queue)
      front-ptr)
    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
                (set! front-ptr new-pair)
                (set! rear-ptr new-pair)
                'ok)
          (else
            (set-cdr! rear-ptr new-pair)
            (set! rear-ptr new-pair)
            'ok)))
      )
    (define (delete-queue!)
      (cond
        ((empty-queue?) (error "Trying to delete on an empty queue!"))
        (else
          (set! front-ptr (cdr front-ptr))
              ))
      )
    (define (dispatch m)
      (cond
        ((eq? m 'insert-queue!) insert-queue!)
        ((eq? m 'print-queue) print-queue)
        ((eq? m 'delete-queue!) delete-queue!)
        ))
    dispatch))

; Helper functions (to have better API)
(define (insert-queue! queue item)
  ((queue 'insert-queue!) item))
(define (delete-queue! queue)
  ((queue 'delete-queue!)))
(define (print-queue queue)
  ((queue 'print-queue)))

; Testing
(define queue1 (make-queue))
(insert-queue! queue1 'a)
(print-queue queue1);Expected: (a)
(insert-queue! queue1 'b)
(print-queue queue1);Expected: (a b)
(insert-queue! queue1 'c)
(print-queue queue1);Expected: (a b c)
(delete-queue! queue1)
(print-queue queue1);Expected: (b c)
